From e38cae38b42a18bb62a87cdf629720feeea32b18 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Thu, 20 Nov 2025 11:13:49 +0000
Subject: [PATCH 03/13] Add driver loader in LinuxLoader.

Implemented a LoadFVLib and it will be called in LinuxLoader entry.
---
 .../Application/LinuxLoader/LinuxLoader.c     |   4 +
 .../Application/LinuxLoader/LinuxLoader.inf   |   1 +
 QcomModulePkg/Include/Library/LoadFVLib.h     |  50 ++++
 QcomModulePkg/Library/LoadFVLib/LoadFVLib.c   | 229 ++++++++++++++++++
 QcomModulePkg/Library/LoadFVLib/LoadFVLib.inf |  24 ++
 QcomModulePkg/QcomModulePkg.dsc               |   1 +
 6 files changed, 309 insertions(+)
 create mode 100644 QcomModulePkg/Include/Library/LoadFVLib.h
 create mode 100644 QcomModulePkg/Library/LoadFVLib/LoadFVLib.c
 create mode 100644 QcomModulePkg/Library/LoadFVLib/LoadFVLib.inf

diff --git a/QcomModulePkg/Application/LinuxLoader/LinuxLoader.c b/QcomModulePkg/Application/LinuxLoader/LinuxLoader.c
index 60483f42..c434a8c6 100644
--- a/QcomModulePkg/Application/LinuxLoader/LinuxLoader.c
+++ b/QcomModulePkg/Application/LinuxLoader/LinuxLoader.c
@@ -83,6 +83,7 @@
 #include <Library/HypervisorMvCalls.h>
 #include <Library/UpdateCmdLine.h>
 #include <Protocol/EFICardInfo.h>
+#include <Library/LoadFVLib.h>
 
 #define MAX_APP_STR_LEN 64
 #define MAX_NUM_FS 10
@@ -284,6 +285,9 @@ LinuxLoaderEntry (IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable)
 
   BootStatsSetTimeStamp (BS_BL_START);
 
+  /* Load Drivers from current FV */
+  LoadDriversFromCurrentFv(ImageHandle);
+
   /* Check if memory card is present; goto flashless if not */
   Status = gBS->LocateProtocol (&gEfiMemCardInfoProtocolGuid, NULL,
                                   (VOID **)&CardInfo);
diff --git a/QcomModulePkg/Application/LinuxLoader/LinuxLoader.inf b/QcomModulePkg/Application/LinuxLoader/LinuxLoader.inf
index 08718a41..18383ddd 100644
--- a/QcomModulePkg/Application/LinuxLoader/LinuxLoader.inf
+++ b/QcomModulePkg/Application/LinuxLoader/LinuxLoader.inf
@@ -103,6 +103,7 @@
 	FastbootLib
 	UbsanLib
 	Lz4Lib
+	LoadFVLib
 
 [LibraryClasses.AARCH64]
 	AesLib
diff --git a/QcomModulePkg/Include/Library/LoadFVLib.h b/QcomModulePkg/Include/Library/LoadFVLib.h
new file mode 100644
index 00000000..81dd6a77
--- /dev/null
+++ b/QcomModulePkg/Include/Library/LoadFVLib.h
@@ -0,0 +1,50 @@
+/**
+  LoadFVLib.h
+
+  Public header for the LoadFV library which provides helpers to
+  enumerate a firmware volume (FV) and load/start PE32 driver images
+  from it.
+
+*/
+
+#ifndef __LOAD_FV_LIB_H__
+#define __LOAD_FV_LIB_H__
+
+#include <Uefi.h>
+#include <Pi/PiFirmwareFile.h>
+#include <Pi/PiFirmwareVolume.h>
+#include <Library/BaseLib.h>
+#include <Library/Debug.h>
+#include <Library/DebugLib.h>
+#include <Protocol/LoadedImage.h>
+#include <Protocol/FirmwareVolume2.h>
+#include <Library/UefiBootServicesTableLib.h>
+
+/**
+  Load all driver-type files from the firmware volume that contains the
+  provided ImageHandle's DeviceHandle and start them.
+
+  @param ImageHandle  Parent image handle used for LoadImage/StartImage.
+
+  @retval EFI_SUCCESS Always returns EFI_SUCCESS unless allocation/protocol calls fail.
+*/
+EFI_STATUS
+LoadDriversFromCurrentFv(
+  IN EFI_HANDLE ImageHandle
+  );
+
+/**
+  Load all driver-type files from a single firmware volume and start them.
+
+  @param ImageHandle   Parent image handle used for LoadImage/StartImage.
+  @param Fv            Pointer to firmware volume protocol.
+
+  @retval EFI_SUCCESS  Operation completed (individual load errors are logged).
+*/
+EFI_STATUS
+LoadDriversFromFv(
+  IN EFI_HANDLE ImageHandle,
+  IN EFI_FIRMWARE_VOLUME2_PROTOCOL *Fv
+  );
+
+#endif // __LOAD_FV_LIB_H__
diff --git a/QcomModulePkg/Library/LoadFVLib/LoadFVLib.c b/QcomModulePkg/Library/LoadFVLib/LoadFVLib.c
new file mode 100644
index 00000000..9cd8af1d
--- /dev/null
+++ b/QcomModulePkg/Library/LoadFVLib/LoadFVLib.c
@@ -0,0 +1,229 @@
+#include <Uefi.h>
+#include <Library/LoadFVLib.h>
+#include <Library/MemoryAllocationLib.h>
+
+/* Helper implementations for FV driver loading (library-local helpers) */
+
+STATIC
+EFI_STATUS
+LoadPeSectionFromFv(
+  IN EFI_FIRMWARE_VOLUME2_PROTOCOL *Fv,
+  IN EFI_GUID *NameGuid,
+  OUT VOID **PeBuf,
+  OUT UINTN *PeSize
+  )
+{
+  UINT32 AuthStatus = 0;
+
+  if (Fv == NULL || NameGuid == NULL || PeBuf == NULL || PeSize == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  *PeBuf = NULL;
+  *PeSize = 0;
+  return Fv->ReadSection(Fv, NameGuid, EFI_SECTION_PE32, 0, PeBuf, PeSize, &AuthStatus);
+}
+
+STATIC
+EFI_STATUS
+LoadAndStartPeImage(
+  IN EFI_HANDLE ParentImageHandle,
+  IN VOID *PeBuf,
+  IN UINTN PeSize,
+  OUT EFI_HANDLE *ImageHandleNew
+  )
+{
+  EFI_STATUS Status;
+
+  if (PeBuf == NULL || PeSize == 0 || ImageHandleNew == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  *ImageHandleNew = NULL;
+
+  Status = gBS->LoadImage(FALSE, ParentImageHandle, NULL, PeBuf, PeSize, ImageHandleNew);
+  if (EFI_ERROR(Status)) {
+    return Status;
+  }
+
+  return gBS->StartImage(*ImageHandleNew, NULL, NULL);
+}
+
+STATIC
+VOID
+ConnectDriverToGopHandles(
+  IN EFI_HANDLE ImageHandleNew
+  )
+{
+  EFI_HANDLE *GopHandles = NULL;
+  UINTN HandleCount = 0;
+  UINTN Idx;
+  EFI_STATUS ConnStatus;
+
+  ConnStatus = gBS->LocateHandleBuffer(ByProtocol, &gEfiGraphicsOutputProtocolGuid, NULL, &HandleCount, &GopHandles);
+  if (!EFI_ERROR(ConnStatus) && HandleCount > 0 && GopHandles != NULL) {
+    DEBUG((EFI_D_INFO, "LoadDriversFromFv: Found %u GOP handles, attempting ConnectController for new driver\n", (UINTN)HandleCount));
+    for (Idx = 0; Idx < HandleCount; Idx++) {
+      DEBUG((EFI_D_INFO, "LoadDriversFromFv: ConnectController on GOP handle %p\n", GopHandles[Idx]));
+      ConnStatus = gBS->ConnectController(GopHandles[Idx], ImageHandleNew, NULL, TRUE);
+      DEBUG((EFI_D_INFO, "LoadDriversFromFv: ConnectController returned %r for handle %p\n", ConnStatus, GopHandles[Idx]));
+    }
+    gBS->FreePool(GopHandles);
+  } else {
+    DEBUG((EFI_D_INFO, "LoadDriversFromFv: No GOP handles found or LocateHandleBuffer failed: %r\n", ConnStatus));
+  }
+}
+
+/**
+  Load all driver-type files from a single firmware volume and start them.
+
+  @param ImageHandle   Parent image handle used for LoadImage/StartImage.
+  @param Fv            Pointer to firmware volume protocol.
+
+  @retval EFI_SUCCESS  Operation completed (individual load errors are logged).
+  @retval other        Allocation or protocol errors.
+*/
+EFI_STATUS
+LoadDriversFromFv(
+  IN EFI_HANDLE ImageHandle,
+  IN EFI_FIRMWARE_VOLUME2_PROTOCOL *Fv
+  )
+{
+  EFI_STATUS Status = EFI_SUCCESS;
+
+  if (Fv == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  DEBUG((EFI_D_INFO, "LoadDriversFromFv: Fv=%p KeySize=%u\n", Fv, (UINTN)Fv->KeySize));
+
+  if (Fv->KeySize == 0) {
+    DEBUG((EFI_D_INFO, "LoadDriversFromFv: FV KeySize==0, nothing to enumerate\n"));
+    return EFI_UNSUPPORTED;
+  }
+
+  VOID *KeyBuf = AllocateZeroPool(Fv->KeySize);
+  if (KeyBuf == NULL) {
+    DEBUG((EFI_D_ERROR, "LoadDriversFromFv: Failed to allocate KeyBuf size %u\n", (UINTN)Fv->KeySize));
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  UINTN LoadedCount = 0;
+
+  while (TRUE) {
+    EFI_FV_FILETYPE FileType = EFI_FV_FILETYPE_ALL;
+    EFI_GUID NameGuid;
+    EFI_FV_FILE_ATTRIBUTES FileAttr;
+    UINTN FileSize = 0;
+
+    Status = Fv->GetNextFile(Fv, KeyBuf, &FileType, &NameGuid, &FileAttr, &FileSize);
+    if (Status == EFI_NOT_FOUND) {
+      DEBUG((EFI_D_INFO, "LoadDriversFromFv: End of FV files\n"));
+      break;
+    }
+    if (EFI_ERROR(Status)) {
+      DEBUG((EFI_D_ERROR, "LoadDriversFromFv: GetNextFile failed: %r\n", Status));
+      break;
+    }
+
+    DEBUG((EFI_D_INFO, "LoadDriversFromFv: FileType=0x%x GUID=%g Size=%u\n", FileType, &NameGuid, (UINTN)FileSize));
+
+    if (FileType != EFI_FV_FILETYPE_DRIVER) {
+      DEBUG((EFI_D_INFO, "LoadDriversFromFv: skip non-driver file\n"));
+      continue;
+    }
+
+    VOID *FileBuf = NULL;
+    UINTN FileBufSize = 0;
+    EFI_FV_FILETYPE FoundType;
+    EFI_FV_FILE_ATTRIBUTES FoundAttr;
+    UINT32 AuthStatus;
+
+    Status = Fv->ReadFile(Fv, &NameGuid, &FileBuf, &FileBufSize, &FoundType, &FoundAttr, &AuthStatus);
+    if (EFI_ERROR(Status) || FileBuf == NULL || FileBufSize == 0) {
+      DEBUG((EFI_D_INFO, "LoadDriversFromFv: ReadFile failed for %g: %r\n", &NameGuid, Status));
+      if (FileBuf != NULL) gBS->FreePool(FileBuf);
+      continue;
+    }
+
+    DEBUG((EFI_D_INFO, "LoadDriversFromFv: ReadFile OK, BufSize=%u FoundType=%u Attr=0x%x Auth=%u\n",
+          (UINTN)FileBufSize, FoundType, FoundAttr, AuthStatus));
+
+    /* Must have a PE image section; read it and load if present */
+    VOID *PeBuf = NULL;
+    UINTN PeSize = 0;
+
+    Status = LoadPeSectionFromFv(Fv, &NameGuid, &PeBuf, &PeSize);
+    if (EFI_ERROR(Status) || PeBuf == NULL || PeSize == 0) {
+      DEBUG((EFI_D_INFO, "LoadDriversFromFv: no PE32 section for %g (ReadSection=%r), skipping\n", &NameGuid, Status));
+      if (PeBuf != NULL) gBS->FreePool(PeBuf);
+      gBS->FreePool(FileBuf);
+      continue;
+    }
+
+    DEBUG((EFI_D_INFO, "LoadDriversFromFv: PE32 section size=%u, attempting LoadImage\n", (UINTN)PeSize));
+
+    EFI_HANDLE ImageHandleNew = NULL;
+    Status = LoadAndStartPeImage(ImageHandle, PeBuf, PeSize, &ImageHandleNew);
+    if (EFI_ERROR(Status)) {
+      DEBUG((EFI_D_ERROR, "LoadDriversFromFv: Load/Start failed for %g: %r\n", &NameGuid, Status));
+      gBS->FreePool(PeBuf);
+      gBS->FreePool(FileBuf);
+      continue;
+    }
+
+    DEBUG((EFI_D_INFO, "LoadDriversFromFv: Started image %p for %g\n", ImageHandleNew, &NameGuid));
+    LoadedCount++;
+
+    /* Trigger DriverBinding Start by connecting the newly-loaded image to GOP controllers */
+    ConnectDriverToGopHandles(ImageHandleNew);
+
+    gBS->FreePool(PeBuf);
+    gBS->FreePool(FileBuf);
+  }
+
+  FreePool(KeyBuf);
+  DEBUG((EFI_D_INFO, "LoadDriversFromFv: Finished, started %u driver(s)\n", LoadedCount));
+  return EFI_SUCCESS;
+}
+
+/**
+  Try to load drivers from the firmware volume that contains the current image.
+  If not found, enumerate all FVs and attempt load from each.
+
+  @param ImageHandle  Parent image handle used for LoadImage/StartImage.
+
+  @retval EFI_SUCCESS Always returns EFI_SUCCESS unless allocation/protocol calls fail.
+*/
+EFI_STATUS
+LoadDriversFromCurrentFv(
+  IN EFI_HANDLE ImageHandle
+  )
+{
+  EFI_STATUS Status;
+  EFI_LOADED_IMAGE_PROTOCOL *LoadedImage = NULL;
+
+  Status = gBS->HandleProtocol(ImageHandle, &gEfiLoadedImageProtocolGuid, (VOID **)&LoadedImage);
+  if (EFI_ERROR(Status) || LoadedImage == NULL) {
+    DEBUG((EFI_D_INFO, "LoadDriversFromCurrentFv: LoadedImage protocol not available on ImageHandle %p, skipping FV driver load\n", ImageHandle));
+    return EFI_SUCCESS; // silently ignore as requested
+  }
+
+  EFI_HANDLE DeviceHandle = LoadedImage->DeviceHandle;
+  EFI_FIRMWARE_VOLUME2_PROTOCOL *Fv = NULL;
+  Status = gBS->HandleProtocol(DeviceHandle, &gEfiFirmwareVolume2ProtocolGuid, (VOID **)&Fv);
+  if (EFI_ERROR(Status) || Fv == NULL) {
+    DEBUG((EFI_D_INFO, "LoadDriversFromCurrentFv: No FirmwareVolume protocol on DeviceHandle %p, skipping\n", DeviceHandle));
+    return EFI_SUCCESS; // ignore other FVs per request
+  }
+
+  DEBUG((EFI_D_INFO, "LoadDriversFromCurrentFv: Found FV on DeviceHandle %p, calling LoadDriversFromFv\n", DeviceHandle));
+  Status = LoadDriversFromFv(ImageHandle, Fv);
+  if (EFI_ERROR(Status)) {
+    DEBUG((EFI_D_ERROR, "LoadDriversFromCurrentFv: LoadDriversFromFv returned %r\n", Status));
+  } else {
+    DEBUG((EFI_D_INFO, "LoadDriversFromCurrentFv: LoadDriversFromFv completed successfully\n"));
+  }
+
+  return EFI_SUCCESS;
+}
\ No newline at end of file
diff --git a/QcomModulePkg/Library/LoadFVLib/LoadFVLib.inf b/QcomModulePkg/Library/LoadFVLib/LoadFVLib.inf
new file mode 100644
index 00000000..34b380e1
--- /dev/null
+++ b/QcomModulePkg/Library/LoadFVLib/LoadFVLib.inf
@@ -0,0 +1,24 @@
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = LoadFVHelper
+  FILE_GUID                      = acc7b526-4970-41d0-acd0-dd7244f9ad0e
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = LoadFVLib
+
+[Sources]
+  LoadFVLib.c
+
+[Protocols]
+	gEfiFirmwareVolume2ProtocolGuid
+  gEfiGraphicsOutputProtocolGuid
+
+[Packages]
+  MdePkg/MdePkg.dec
+	QcomModulePkg/QcomModulePkg.dec
+
+[LibraryClasses]
+  PcdLib
+  PrintLib
+  BaseLib
+  DebugLib
diff --git a/QcomModulePkg/QcomModulePkg.dsc b/QcomModulePkg/QcomModulePkg.dsc
index 87f10fc8..275d50cb 100644
--- a/QcomModulePkg/QcomModulePkg.dsc
+++ b/QcomModulePkg/QcomModulePkg.dsc
@@ -257,4 +257,5 @@
 			AesLib|QcomModulePkg/Library/aes/AesLib.inf
 			UbsanLib|QcomModulePkg/Library/UbsanLib/UbsanLib.inf
 			Lz4Lib|QcomModulePkg/Library/lz4/lib/Lz4Lib.inf
+            LoadFVLib|QcomModulePkg/Library/LoadFVLib/LoadFVLib.inf
 	}
-- 
2.43.0

