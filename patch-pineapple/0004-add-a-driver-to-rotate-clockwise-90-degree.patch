From 3d44a54c73c6c27eb943b091f5d9c08fbdfae67c Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Thu, 20 Nov 2025 11:15:42 +0000
Subject: [PATCH 04/10] add a driver to rotate clockwise 90 degree.

Currently only support 90 degree.
---
 .../Driver/GopFBRotate/GopFBRotate.c          | 922 ++++++++++++++++++
 .../Driver/GopFBRotate/GopFBRotate.inf        |  49 +
 QcomModulePkg/QcomModulePkg.dec               |   8 +
 QcomModulePkg/QcomModulePkg.dsc               |   9 +
 QcomModulePkg/QcomModulePkg.fdf               |   1 +
 5 files changed, 989 insertions(+)
 create mode 100644 QcomModulePkg/Driver/GopFBRotate/GopFBRotate.c
 create mode 100644 QcomModulePkg/Driver/GopFBRotate/GopFBRotate.inf

diff --git a/QcomModulePkg/Driver/GopFBRotate/GopFBRotate.c b/QcomModulePkg/Driver/GopFBRotate/GopFBRotate.c
new file mode 100644
index 00000000..1c248900
--- /dev/null
+++ b/QcomModulePkg/Driver/GopFBRotate/GopFBRotate.c
@@ -0,0 +1,922 @@
+#include <Uefi.h>
+#include <Library/BaseLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/CacheMaintenanceLib.h>
+#include <Library/DebugLib.h>
+#include <Library/FrameBufferBltLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiLib.h>
+#include <Library/DxeServicesTableLib.h>
+#include <Protocol/DevicePath.h>
+#include <Protocol/GraphicsOutput.h>
+#include <Protocol/EFIKernelInterface.h>
+
+/// Defines
+/*
+ * Convert enum video_log2_bpp to bytes and bits. Note we omit the outer
+ * brackets to allow multiplication by fractional pixels.
+ */
+#define VNBYTES(bpix) (1 << (bpix)) / 8
+#define VNBITS(bpix) (1 << (bpix))
+
+#define POS_TO_FB(posX, posY)                                                  \
+  ((UINT8                                                                      \
+        *)((UINTN)This->Mode->FrameBufferBase + (posY)*This->Mode->Info->PixelsPerScanLine * FB_BYTES_PER_PIXEL + (posX)*FB_BYTES_PER_PIXEL))
+
+#define FB_BITS_PER_PIXEL (32)
+#define FB_BYTES_PER_PIXEL (FB_BITS_PER_PIXEL / 8)
+#define DISPLAYDXE_PHYSICALADDRESS32(_x_) (UINTN)((_x_)&0xFFFFFFFF)
+
+#define DISPLAYDXE_RED_MASK 0xFF0000
+#define DISPLAYDXE_GREEN_MASK 0x00FF00
+#define DISPLAYDXE_BLUE_MASK 0x0000FF
+#define DISPLAYDXE_ALPHA_MASK 0x000000
+
+static int __attribute__ ( (no_sanitize ("safe-stack")))
+RotateFramebufferTask(
+    VOID *Params
+);
+
+typedef struct {
+  EFI_KERNEL_PROTOCOL *KernIntf;
+  EFI_PHYSICAL_ADDRESS FakeFrameBufferAddr;
+  EFI_PHYSICAL_ADDRESS HwFrameBufferAddr;
+} FrameBufferRotateTaskParams;
+
+STATIC FrameBufferRotateTaskParams gTaskParams = {0};
+
+#if defined(__aarch64__)
+STATIC VOID RotateFramebufferNeon(
+    UINT8 *Src,
+    UINT8 *Dst,
+    UINTN Horizontal,
+    UINTN Vertical,
+    UINTN SrcStride,
+    UINTN DstStride)
+{
+    const UINTN blockH = 8;
+    const UINTN blockW = 8;
+    UINTN r, c;
+    for (r = 0; r + blockH <= Vertical; r += blockH) {
+        for (c = 0; c + blockW <= Horizontal; c += blockW) {
+            UINT8 *row0 = Src + (r + 0) * SrcStride + c * FB_BYTES_PER_PIXEL;
+            UINT8 *row1 = Src + (r + 1) * SrcStride + c * FB_BYTES_PER_PIXEL;
+            UINT8 *row2 = Src + (r + 2) * SrcStride + c * FB_BYTES_PER_PIXEL;
+            UINT8 *row3 = Src + (r + 3) * SrcStride + c * FB_BYTES_PER_PIXEL;
+            UINT8 *row4 = Src + (r + 4) * SrcStride + c * FB_BYTES_PER_PIXEL;
+            UINT8 *row5 = Src + (r + 5) * SrcStride + c * FB_BYTES_PER_PIXEL;
+            UINT8 *row6 = Src + (r + 6) * SrcStride + c * FB_BYTES_PER_PIXEL;
+            UINT8 *row7 = Src + (r + 7) * SrcStride + c * FB_BYTES_PER_PIXEL;
+            UINT8 *row0b = row0 + 4 * FB_BYTES_PER_PIXEL;
+            UINT8 *row1b = row1 + 4 * FB_BYTES_PER_PIXEL;
+            UINT8 *row2b = row2 + 4 * FB_BYTES_PER_PIXEL;
+            UINT8 *row3b = row3 + 4 * FB_BYTES_PER_PIXEL;
+            UINT8 *row4b = row4 + 4 * FB_BYTES_PER_PIXEL;
+            UINT8 *row5b = row5 + 4 * FB_BYTES_PER_PIXEL;
+            UINT8 *row6b = row6 + 4 * FB_BYTES_PER_PIXEL;
+            UINT8 *row7b = row7 + 4 * FB_BYTES_PER_PIXEL;
+
+            __asm__ __volatile__(
+                "prfm pldl1keep, [%[r0]]\n"
+                "prfm pldl1keep, [%[r1]]\n"
+                "prfm pldl1keep, [%[r2]]\n"
+                "prfm pldl1keep, [%[r3]]\n"
+                : : [r0]"r"(row0), [r1]"r"(row1), [r2]"r"(row2), [r3]"r"(row3));
+
+            UINTN fr0 = (Vertical - 1 - (r + 0));
+            UINTN fr1 = (Vertical - 1 - (r + 1));
+            UINTN fr2 = (Vertical - 1 - (r + 2));
+            UINTN fr3 = (Vertical - 1 - (r + 3));
+            UINTN fr4 = (Vertical - 1 - (r + 4));
+            UINTN fr5 = (Vertical - 1 - (r + 5));
+            UINTN fr6 = (Vertical - 1 - (r + 6));
+            UINTN fr7 = (Vertical - 1 - (r + 7));
+
+            UINT8 *colBase = Dst + c * DstStride;
+            UINT8 *colBaseB = colBase + 4 * DstStride;
+
+                        UINT32 c00,c10,c20,c30,c01,c11,c21,c31,c02,c12,c22,c32,c03,c13,c23,c33;
+                        UINT32 d00,d10,d20,d30,d01,d11,d21,d31,d02,d12,d22,d32,d03,d13,d23,d33;
+                        UINT32 bc00,bc10,bc20,bc30,bc01,bc11,bc21,bc31,bc02,bc12,bc22,bc32,bc03,bc13,bc23,bc33;
+                        UINT32 bd00,bd10,bd20,bd30,bd01,bd11,bd21,bd31,bd02,bd12,bd22,bd32,bd03,bd13,bd23,bd33;
+
+                        __asm__ __volatile__(
+                                "ld1 {v0.4s}, [%[r0]]\n"
+                                "ld1 {v1.4s}, [%[r1]]\n"
+                                "ld1 {v2.4s}, [%[r2]]\n"
+                                "ld1 {v3.4s}, [%[r3]]\n"
+                                "trn1 v4.4s, v0.4s, v1.4s\n"
+                                "trn2 v5.4s, v0.4s, v1.4s\n"
+                                "trn1 v6.4s, v2.4s, v3.4s\n"
+                                "trn2 v7.4s, v2.4s, v3.4s\n"
+                                "trn1 v0.2d, v4.2d, v6.2d\n" // col0
+                                "trn2 v1.2d, v4.2d, v6.2d\n" // col2
+                                "trn1 v2.2d, v5.2d, v7.2d\n" // col1
+                                "trn2 v3.2d, v5.2d, v7.2d\n" // col3
+                                "umov %w[c00], v0.s[0]\n"
+                                "umov %w[c10], v0.s[1]\n"
+                                "umov %w[c20], v0.s[2]\n"
+                                "umov %w[c30], v0.s[3]\n"
+                                "umov %w[c01], v2.s[0]\n"
+                                "umov %w[c11], v2.s[1]\n"
+                                "umov %w[c21], v2.s[2]\n"
+                                "umov %w[c31], v2.s[3]\n"
+                                "umov %w[c02], v1.s[0]\n"
+                                "umov %w[c12], v1.s[1]\n"
+                                "umov %w[c22], v1.s[2]\n"
+                                "umov %w[c32], v1.s[3]\n"
+                                "umov %w[c03], v3.s[0]\n"
+                                "umov %w[c13], v3.s[1]\n"
+                                "umov %w[c23], v3.s[2]\n"
+                                "umov %w[c33], v3.s[3]\n"
+                                : [c00]"=r"(c00),[c10]"=r"(c10),[c20]"=r"(c20),[c30]"=r"(c30),
+                                    [c01]"=r"(c01),[c11]"=r"(c11),[c21]"=r"(c21),[c31]"=r"(c31),
+                                    [c02]"=r"(c02),[c12]"=r"(c12),[c22]"=r"(c22),[c32]"=r"(c32),
+                                    [c03]"=r"(c03),[c13]"=r"(c13),[c23]"=r"(c23),[c33]"=r"(c33)
+                                : [r0]"r"(row0), [r1]"r"(row1), [r2]"r"(row2), [r3]"r"(row3)
+                                : "memory", "v0","v1","v2","v3","v4","v5","v6","v7");
+
+                        *(UINT32*)(colBase + fr0 * FB_BYTES_PER_PIXEL) = c00;
+                        *(UINT32*)(colBase + fr1 * FB_BYTES_PER_PIXEL) = c10;
+                        *(UINT32*)(colBase + fr2 * FB_BYTES_PER_PIXEL) = c20;
+                        *(UINT32*)(colBase + fr3 * FB_BYTES_PER_PIXEL) = c30;
+                        *(UINT32*)(colBase + DstStride + fr0 * FB_BYTES_PER_PIXEL) = c02;
+                        *(UINT32*)(colBase + DstStride + fr1 * FB_BYTES_PER_PIXEL) = c12;
+                        *(UINT32*)(colBase + DstStride + fr2 * FB_BYTES_PER_PIXEL) = c22;
+                        *(UINT32*)(colBase + DstStride + fr3 * FB_BYTES_PER_PIXEL) = c32;
+                        *(UINT32*)(colBase + 2*DstStride + fr0 * FB_BYTES_PER_PIXEL) = c01;
+                        *(UINT32*)(colBase + 2*DstStride + fr1 * FB_BYTES_PER_PIXEL) = c11;
+                        *(UINT32*)(colBase + 2*DstStride + fr2 * FB_BYTES_PER_PIXEL) = c21;
+                        *(UINT32*)(colBase + 2*DstStride + fr3 * FB_BYTES_PER_PIXEL) = c31;
+                        *(UINT32*)(colBase + 3*DstStride + fr0 * FB_BYTES_PER_PIXEL) = c03;
+                        *(UINT32*)(colBase + 3*DstStride + fr1 * FB_BYTES_PER_PIXEL) = c13;
+                        *(UINT32*)(colBase + 3*DstStride + fr2 * FB_BYTES_PER_PIXEL) = c23;
+                        *(UINT32*)(colBase + 3*DstStride + fr3 * FB_BYTES_PER_PIXEL) = c33;
+
+                        __asm__ __volatile__(
+                                "ld1 {v0.4s}, [%[r0b]]\n"
+                                "ld1 {v1.4s}, [%[r1b]]\n"
+                                "ld1 {v2.4s}, [%[r2b]]\n"
+                                "ld1 {v3.4s}, [%[r3b]]\n"
+                                "trn1 v4.4s, v0.4s, v1.4s\n"
+                                "trn2 v5.4s, v0.4s, v1.4s\n"
+                                "trn1 v6.4s, v2.4s, v3.4s\n"
+                                "trn2 v7.4s, v2.4s, v3.4s\n"
+                                "trn1 v0.2d, v4.2d, v6.2d\n"
+                                "trn2 v1.2d, v4.2d, v6.2d\n"
+                                "trn1 v2.2d, v5.2d, v7.2d\n"
+                                "trn2 v3.2d, v5.2d, v7.2d\n"
+                                "umov %w[d00], v0.s[0]\n"
+                                "umov %w[d10], v0.s[1]\n"
+                                "umov %w[d20], v0.s[2]\n"
+                                "umov %w[d30], v0.s[3]\n"
+                                "umov %w[d01], v2.s[0]\n"
+                                "umov %w[d11], v2.s[1]\n"
+                                "umov %w[d21], v2.s[2]\n"
+                                "umov %w[d31], v2.s[3]\n"
+                                "umov %w[d02], v1.s[0]\n"
+                                "umov %w[d12], v1.s[1]\n"
+                                "umov %w[d22], v1.s[2]\n"
+                                "umov %w[d32], v1.s[3]\n"
+                                "umov %w[d03], v3.s[0]\n"
+                                "umov %w[d13], v3.s[1]\n"
+                                "umov %w[d23], v3.s[2]\n"
+                                "umov %w[d33], v3.s[3]\n"
+                                : [d00]"=r"(d00),[d10]"=r"(d10),[d20]"=r"(d20),[d30]"=r"(d30),
+                                    [d01]"=r"(d01),[d11]"=r"(d11),[d21]"=r"(d21),[d31]"=r"(d31),
+                                    [d02]"=r"(d02),[d12]"=r"(d12),[d22]"=r"(d22),[d32]"=r"(d32),
+                                    [d03]"=r"(d03),[d13]"=r"(d13),[d23]"=r"(d23),[d33]"=r"(d33)
+                                : [r0b]"r"(row0b), [r1b]"r"(row1b), [r2b]"r"(row2b), [r3b]"r"(row3b)
+                                : "memory", "v0","v1","v2","v3","v4","v5","v6","v7");
+                        *(UINT32*)(colBaseB + fr0 * FB_BYTES_PER_PIXEL) = d00;
+                        *(UINT32*)(colBaseB + fr1 * FB_BYTES_PER_PIXEL) = d10;
+                        *(UINT32*)(colBaseB + fr2 * FB_BYTES_PER_PIXEL) = d20;
+                        *(UINT32*)(colBaseB + fr3 * FB_BYTES_PER_PIXEL) = d30;
+                        *(UINT32*)(colBaseB + DstStride + fr0 * FB_BYTES_PER_PIXEL) = d02;
+                        *(UINT32*)(colBaseB + DstStride + fr1 * FB_BYTES_PER_PIXEL) = d12;
+                        *(UINT32*)(colBaseB + DstStride + fr2 * FB_BYTES_PER_PIXEL) = d22;
+                        *(UINT32*)(colBaseB + DstStride + fr3 * FB_BYTES_PER_PIXEL) = d32;
+                        *(UINT32*)(colBaseB + 2*DstStride + fr0 * FB_BYTES_PER_PIXEL) = d01;
+                        *(UINT32*)(colBaseB + 2*DstStride + fr1 * FB_BYTES_PER_PIXEL) = d11;
+                        *(UINT32*)(colBaseB + 2*DstStride + fr2 * FB_BYTES_PER_PIXEL) = d21;
+                        *(UINT32*)(colBaseB + 2*DstStride + fr3 * FB_BYTES_PER_PIXEL) = d31;
+                        *(UINT32*)(colBaseB + 3*DstStride + fr0 * FB_BYTES_PER_PIXEL) = d03;
+                        *(UINT32*)(colBaseB + 3*DstStride + fr1 * FB_BYTES_PER_PIXEL) = d13;
+                        *(UINT32*)(colBaseB + 3*DstStride + fr2 * FB_BYTES_PER_PIXEL) = d23;
+                        *(UINT32*)(colBaseB + 3*DstStride + fr3 * FB_BYTES_PER_PIXEL) = d33;
+
+                        // 底半部分 4 列
+                        UINT8 *colBaseBottom = colBase; // 同列索引，不同行翻转位置
+                        UINT8 *colBaseBottomB = colBaseB;
+                        __asm__ __volatile__(
+                                "ld1 {v0.4s}, [%[r4]]\n"
+                                "ld1 {v1.4s}, [%[r5]]\n"
+                                "ld1 {v2.4s}, [%[r6]]\n"
+                                "ld1 {v3.4s}, [%[r7]]\n"
+                                "trn1 v4.4s, v0.4s, v1.4s\n"
+                                "trn2 v5.4s, v0.4s, v1.4s\n"
+                                "trn1 v6.4s, v2.4s, v3.4s\n"
+                                "trn2 v7.4s, v2.4s, v3.4s\n"
+                                "trn1 v0.2d, v4.2d, v6.2d\n"
+                                "trn2 v1.2d, v4.2d, v6.2d\n"
+                                "trn1 v2.2d, v5.2d, v7.2d\n"
+                                "trn2 v3.2d, v5.2d, v7.2d\n"
+                                "umov %w[bc00], v0.s[0]\n"
+                                "umov %w[bc10], v0.s[1]\n"
+                                "umov %w[bc20], v0.s[2]\n"
+                                "umov %w[bc30], v0.s[3]\n"
+                                "umov %w[bc01], v2.s[0]\n"
+                                "umov %w[bc11], v2.s[1]\n"
+                                "umov %w[bc21], v2.s[2]\n"
+                                "umov %w[bc31], v2.s[3]\n"
+                                "umov %w[bc02], v1.s[0]\n"
+                                "umov %w[bc12], v1.s[1]\n"
+                                "umov %w[bc22], v1.s[2]\n"
+                                "umov %w[bc32], v1.s[3]\n"
+                                "umov %w[bc03], v3.s[0]\n"
+                                "umov %w[bc13], v3.s[1]\n"
+                                "umov %w[bc23], v3.s[2]\n"
+                                "umov %w[bc33], v3.s[3]\n"
+                                : [bc00]"=r"(bc00),[bc10]"=r"(bc10),[bc20]"=r"(bc20),[bc30]"=r"(bc30),
+                                    [bc01]"=r"(bc01),[bc11]"=r"(bc11),[bc21]"=r"(bc21),[bc31]"=r"(bc31),
+                                    [bc02]"=r"(bc02),[bc12]"=r"(bc12),[bc22]"=r"(bc22),[bc32]"=r"(bc32),
+                                    [bc03]"=r"(bc03),[bc13]"=r"(bc13),[bc23]"=r"(bc23),[bc33]"=r"(bc33)
+                                : [r4]"r"(row4), [r5]"r"(row5), [r6]"r"(row6), [r7]"r"(row7)
+                                : "memory", "v0","v1","v2","v3","v4","v5","v6","v7");
+                        *(UINT32*)(colBaseBottom + fr4 * FB_BYTES_PER_PIXEL) = bc00;
+                        *(UINT32*)(colBaseBottom + fr5 * FB_BYTES_PER_PIXEL) = bc10;
+                        *(UINT32*)(colBaseBottom + fr6 * FB_BYTES_PER_PIXEL) = bc20;
+                        *(UINT32*)(colBaseBottom + fr7 * FB_BYTES_PER_PIXEL) = bc30;
+                        *(UINT32*)(colBaseBottom + DstStride + fr4 * FB_BYTES_PER_PIXEL) = bc02;
+                        *(UINT32*)(colBaseBottom + DstStride + fr5 * FB_BYTES_PER_PIXEL) = bc12;
+                        *(UINT32*)(colBaseBottom + DstStride + fr6 * FB_BYTES_PER_PIXEL) = bc22;
+                        *(UINT32*)(colBaseBottom + DstStride + fr7 * FB_BYTES_PER_PIXEL) = bc32;
+                        *(UINT32*)(colBaseBottom + 2*DstStride + fr4 * FB_BYTES_PER_PIXEL) = bc01;
+                        *(UINT32*)(colBaseBottom + 2*DstStride + fr5 * FB_BYTES_PER_PIXEL) = bc11;
+                        *(UINT32*)(colBaseBottom + 2*DstStride + fr6 * FB_BYTES_PER_PIXEL) = bc21;
+                        *(UINT32*)(colBaseBottom + 2*DstStride + fr7 * FB_BYTES_PER_PIXEL) = bc31;
+                        *(UINT32*)(colBaseBottom + 3*DstStride + fr4 * FB_BYTES_PER_PIXEL) = bc03;
+                        *(UINT32*)(colBaseBottom + 3*DstStride + fr5 * FB_BYTES_PER_PIXEL) = bc13;
+                        *(UINT32*)(colBaseBottom + 3*DstStride + fr6 * FB_BYTES_PER_PIXEL) = bc23;
+                        *(UINT32*)(colBaseBottom + 3*DstStride + fr7 * FB_BYTES_PER_PIXEL) = bc33;
+
+                        __asm__ __volatile__(
+                                "ld1 {v0.4s}, [%[r4b]]\n"
+                                "ld1 {v1.4s}, [%[r5b]]\n"
+                                "ld1 {v2.4s}, [%[r6b]]\n"
+                                "ld1 {v3.4s}, [%[r7b]]\n"
+                                "trn1 v4.4s, v0.4s, v1.4s\n"
+                                "trn2 v5.4s, v0.4s, v1.4s\n"
+                                "trn1 v6.4s, v2.4s, v3.4s\n"
+                                "trn2 v7.4s, v2.4s, v3.4s\n"
+                                "trn1 v0.2d, v4.2d, v6.2d\n"
+                                "trn2 v1.2d, v4.2d, v6.2d\n"
+                                "trn1 v2.2d, v5.2d, v7.2d\n"
+                                "trn2 v3.2d, v5.2d, v7.2d\n"
+                                "umov %w[bd00], v0.s[0]\n"
+                                "umov %w[bd10], v0.s[1]\n"
+                                "umov %w[bd20], v0.s[2]\n"
+                                "umov %w[bd30], v0.s[3]\n"
+                                "umov %w[bd01], v2.s[0]\n"
+                                "umov %w[bd11], v2.s[1]\n"
+                                "umov %w[bd21], v2.s[2]\n"
+                                "umov %w[bd31], v2.s[3]\n"
+                                "umov %w[bd02], v1.s[0]\n"
+                                "umov %w[bd12], v1.s[1]\n"
+                                "umov %w[bd22], v1.s[2]\n"
+                                "umov %w[bd32], v1.s[3]\n"
+                                "umov %w[bd03], v3.s[0]\n"
+                                "umov %w[bd13], v3.s[1]\n"
+                                "umov %w[bd23], v3.s[2]\n"
+                                "umov %w[bd33], v3.s[3]\n"
+                                : [bd00]"=r"(bd00),[bd10]"=r"(bd10),[bd20]"=r"(bd20),[bd30]"=r"(bd30),
+                                    [bd01]"=r"(bd01),[bd11]"=r"(bd11),[bd21]"=r"(bd21),[bd31]"=r"(bd31),
+                                    [bd02]"=r"(bd02),[bd12]"=r"(bd12),[bd22]"=r"(bd22),[bd32]"=r"(bd32),
+                                    [bd03]"=r"(bd03),[bd13]"=r"(bd13),[bd23]"=r"(bd23),[bd33]"=r"(bd33)
+                                : [r4b]"r"(row4b), [r5b]"r"(row5b), [r6b]"r"(row6b), [r7b]"r"(row7b)
+                                : "memory", "v0","v1","v2","v3","v4","v5","v6","v7");
+                        *(UINT32*)(colBaseBottomB + fr4 * FB_BYTES_PER_PIXEL) = bd00;
+                        *(UINT32*)(colBaseBottomB + fr5 * FB_BYTES_PER_PIXEL) = bd10;
+                        *(UINT32*)(colBaseBottomB + fr6 * FB_BYTES_PER_PIXEL) = bd20;
+                        *(UINT32*)(colBaseBottomB + fr7 * FB_BYTES_PER_PIXEL) = bd30;
+                        *(UINT32*)(colBaseBottomB + DstStride + fr4 * FB_BYTES_PER_PIXEL) = bd02;
+                        *(UINT32*)(colBaseBottomB + DstStride + fr5 * FB_BYTES_PER_PIXEL) = bd12;
+                        *(UINT32*)(colBaseBottomB + DstStride + fr6 * FB_BYTES_PER_PIXEL) = bd22;
+                        *(UINT32*)(colBaseBottomB + DstStride + fr7 * FB_BYTES_PER_PIXEL) = bd32;
+                        *(UINT32*)(colBaseBottomB + 2*DstStride + fr4 * FB_BYTES_PER_PIXEL) = bd01;
+                        *(UINT32*)(colBaseBottomB + 2*DstStride + fr5 * FB_BYTES_PER_PIXEL) = bd11;
+                        *(UINT32*)(colBaseBottomB + 2*DstStride + fr6 * FB_BYTES_PER_PIXEL) = bd21;
+                        *(UINT32*)(colBaseBottomB + 2*DstStride + fr7 * FB_BYTES_PER_PIXEL) = bd31;
+                        *(UINT32*)(colBaseBottomB + 3*DstStride + fr4 * FB_BYTES_PER_PIXEL) = bd03;
+                        *(UINT32*)(colBaseBottomB + 3*DstStride + fr5 * FB_BYTES_PER_PIXEL) = bd13;
+                        *(UINT32*)(colBaseBottomB + 3*DstStride + fr6 * FB_BYTES_PER_PIXEL) = bd23;
+                        *(UINT32*)(colBaseBottomB + 3*DstStride + fr7 * FB_BYTES_PER_PIXEL) = bd33;
+        }
+    }
+
+    for (; r < Vertical; ++r) {
+        for (c = 0; c < Horizontal; ++c) {
+            UINT8 *SrcPixel = Src + r * SrcStride + c * FB_BYTES_PER_PIXEL;
+            UINT8 *DstPixel = Dst + c * DstStride + (Vertical - 1 - r) * FB_BYTES_PER_PIXEL;
+            *(UINT32*)DstPixel = *(UINT32*)SrcPixel;
+        }
+    }
+    for (c = (Horizontal & ~(blockW-1)); c < Horizontal; ++c) {
+        for (r = 0; r < (Vertical & ~(blockH-1)); ++r) {
+            UINT8 *SrcPixel = Src + r * SrcStride + c * FB_BYTES_PER_PIXEL;
+            UINT8 *DstPixel = Dst + c * DstStride + (Vertical - 1 - r) * FB_BYTES_PER_PIXEL;
+            *(UINT32*)DstPixel = *(UINT32*)SrcPixel;
+        }
+    }
+}
+#endif
+
+/* Rotate in-memory fake framebuffer */
+EFI_STATUS
+EFIAPI
+StartRotateTask(
+  IN EFI_PHYSICAL_ADDRESS FakeFrameBufferAddr,
+  IN EFI_PHYSICAL_ADDRESS HwFrameBufferAddr
+){
+  EFI_STATUS Status = EFI_SUCCESS;
+  Thread* FBRotateTD = NULL;
+
+  // Locate multithread kernel protocol
+  STATIC EFI_KERNEL_PROTOCOL  *KernIntf = NULL;
+  Status = gBS->LocateProtocol (&gEfiKernelProtocolGuid, NULL, (VOID **)&KernIntf);
+  if (EFI_ERROR (Status) || (KernIntf == NULL)) {
+      DEBUG ((DEBUG_ERROR, "GopFBRotateEntryPoint: LocateProtocol gEfiKernelProtocolGuid returned %r\n", Status));
+      return Status;
+  }
+
+  // Initialize static parameters
+  gTaskParams.KernIntf = KernIntf;
+  gTaskParams.FakeFrameBufferAddr = FakeFrameBufferAddr;
+  gTaskParams.HwFrameBufferAddr = HwFrameBufferAddr;
+
+  FBRotateTD = KernIntf->Thread->ThreadCreate ("FrameBufferRotateThread",
+      &RotateFramebufferTask, &gTaskParams, UEFI_THREAD_PRIORITY + 1,
+      DEFAULT_STACK_SIZE);
+
+  if (FBRotateTD == NULL) {
+      return EFI_NOT_READY;
+  }
+
+  // Set cpu index to next core
+  UINT32 active_mask = KernIntf->MpCpu->MpcoreGetActiveMask();
+  DEBUG((DEBUG_INFO, "GopFBRotateEntryPoint: Active CPU Mask: 0x%X\n", active_mask));
+  UINT32 max_cpu = 0;
+  while (active_mask >>= 1)
+    max_cpu++;
+  if(max_cpu>7)
+    max_cpu =7;
+  DEBUG((DEBUG_INFO, "GopFBRotateEntryPoint: Setting Rotate Thread to CPU %u\n", max_cpu));
+  KernIntf->Thread->ThreadSetPinnedCpu(FBRotateTD, max_cpu);
+
+  Status = KernIntf->Thread->ThreadResume (FBRotateTD);
+  if (EFI_ERROR (Status)) {
+      DEBUG ((DEBUG_WARN, "GopFBRotateEntryPoint: ThreadResume returned %r\n", Status));
+      return Status;
+  }
+  
+  return Status;
+}
+
+static int __attribute__ ( (no_sanitize ("safe-stack")))
+RotateFramebufferTask(
+    VOID *Params
+){
+    UINTN                                 Horizontal;
+    UINTN                                 Vertical;
+    UINTN                                 BytesPerPixel;
+    UINTN                                 SrcStride;
+    UINTN                                 DstStride;
+    UINT8                                *Src;
+    UINT8                                *Dst;
+    FrameBufferRotateTaskParams *TaskParams = (FrameBufferRotateTaskParams *)Params;
+
+    DEBUG((DEBUG_INFO, "RotateFramebuffer: Running on CPU %u\n",
+        ((EFI_KERNEL_PROTOCOL *)TaskParams->KernIntf)->MpCpu->MpcoreGetCurrCpu()));
+
+      // Validate parameters immediately to avoid null pointer dereference
+    if (TaskParams == NULL) {
+        DEBUG((DEBUG_ERROR, "RotateFramebuffer: TaskParams is NULL!\n"));
+        return -1;
+    }
+
+    if (TaskParams->KernIntf == NULL) {
+        DEBUG((DEBUG_ERROR, "RotateFramebuffer: KernIntf is NULL!\n"));
+        return -1;
+    }
+
+    Horizontal    = FixedPcdGet32(PcdMipiFrameBufferWidth);
+    Vertical      = FixedPcdGet32(PcdMipiFrameBufferHeight);
+    BytesPerPixel = FB_BYTES_PER_PIXEL;
+    SrcStride     = Horizontal * BytesPerPixel;
+    DstStride     = Vertical * BytesPerPixel;
+
+    if ((Horizontal == 0) || (Vertical == 0) || (SrcStride == 0) || (DstStride == 0)) {
+        DEBUG((DEBUG_ERROR, "RotateFramebuffer: Invalid parameters\n"));
+        return -1;
+    }
+
+    Src = (UINT8 *)DISPLAYDXE_PHYSICALADDRESS32(TaskParams->FakeFrameBufferAddr);
+    Dst = (UINT8 *)DISPLAYDXE_PHYSICALADDRESS32(TaskParams->HwFrameBufferAddr);
+
+    // The Task will handle 90 degree rotation all the time
+    #if defined(__aarch64__)
+      DEBUG((DEBUG_INFO, "RotateFramebuffer: Using NEON accelerated rotation\n"));
+    #endif
+    do {
+        #if defined(__aarch64__)
+        RotateFramebufferNeon(Src, Dst, Horizontal, Vertical, SrcStride, DstStride);
+        #else
+        for (UINTN Row = 0; Row < Vertical; ++Row) {
+            UINT8 *SrcRow = Src + Row * SrcStride;
+            for (UINTN Col = 0; Col < Horizontal; ++Col) {
+                UINT8 *SrcPixel = SrcRow + Col * BytesPerPixel;
+                UINT8 *DstPixel = Dst + Col * DstStride + (Vertical - 1 - Row) * BytesPerPixel;
+                CopyMem(DstPixel, SrcPixel, BytesPerPixel);
+            }
+        }
+        #endif
+
+        // 100ms ~= 10fps, memcpy also need time.
+        // Cpu need to take a rest to not be hot.
+        ((EFI_KERNEL_PROTOCOL *)TaskParams->KernIntf)->Thread->ThreadSleep(100);
+    }
+    while(1);
+
+
+}
+
+// Scan all installed GOP handles and print mode information for each
+STATIC EFI_STATUS
+ScanGop(VOID)
+{
+    EFI_STATUS Status;
+    EFI_HANDLE *HandleBuffer = NULL;
+    UINTN HandleCount = 0;
+    UINTN Index;
+
+    Status = gBS->LocateHandleBuffer(ByProtocol, &gEfiGraphicsOutputProtocolGuid, NULL, &HandleCount, &HandleBuffer);
+    DEBUG((DEBUG_INFO, "ScanGop: LocateHandleBuffer returned %r, HandleCount=%u, HandleBuffer=%p\n", Status, HandleCount, HandleBuffer));
+    if (EFI_ERROR(Status) || HandleCount == 0) {
+        DEBUG((DEBUG_WARN, "ScanGop: no GOP handles found\n"));
+        return EFI_NOT_FOUND;
+    }
+
+    for (Index = 0; Index < HandleCount; ++Index) {
+        EFI_GRAPHICS_OUTPUT_PROTOCOL *Gop = NULL;
+        Status = gBS->HandleProtocol(HandleBuffer[Index], &gEfiGraphicsOutputProtocolGuid, (VOID **)&Gop);
+        DEBUG((DEBUG_INFO, "ScanGop: handle[%u]=%p HandleProtocol returned %r, Gop=%p\n", Index, HandleBuffer[Index], Status, Gop));
+        if (EFI_ERROR(Status) || Gop == NULL) {
+            continue;
+        }
+
+        if (Gop->Mode == NULL) {
+            DEBUG((DEBUG_WARN, "  GOP mode structure is NULL\n"));
+            continue;
+        }
+
+        DEBUG((DEBUG_INFO, "  CurrentMode=%u, MaxMode=%u, FrameBufferBase=%p, FrameBufferSize=%lu\n",
+               (UINT32)Gop->Mode->Mode,
+               (UINT32)Gop->Mode->MaxMode,
+               (VOID *)Gop->Mode->FrameBufferBase,
+               (unsigned long)Gop->Mode->FrameBufferSize));
+
+        if (Gop->Mode->Info != NULL) {
+            EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *Info = Gop->Mode->Info;
+                 DEBUG((DEBUG_INFO, "    CurrentInfo: %ux%u PPL=%u PixelFormat=%u\n",
+                     (UINT32)Info->HorizontalResolution,
+                     (UINT32)Info->VerticalResolution,
+                     (UINT32)Info->PixelsPerScanLine,
+                     (UINT32)Info->PixelFormat));
+                 DEBUG((DEBUG_INFO, "    PixelBitMask: R=%08x G=%08x B=%08x Res=%08x\n",
+                     Info->PixelInformation.RedMask,
+                     Info->PixelInformation.GreenMask,
+                     Info->PixelInformation.BlueMask,
+                     Info->PixelInformation.ReservedMask));
+        }
+
+        // List all available modes via QueryMode
+        if (Gop->Mode->MaxMode > 0) {
+            UINT32 ModeNumber;
+            for (ModeNumber = 0; ModeNumber < (UINT32)Gop->Mode->MaxMode; ++ModeNumber) {
+                EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *Info = NULL;
+                UINTN SizeOfInfo = 0;
+                Status = Gop->QueryMode(Gop, ModeNumber, &SizeOfInfo, &Info);
+                DEBUG((DEBUG_INFO, "    QueryMode %u returned %r, SizeOfInfo=%u, Info=%p\n", ModeNumber, Status, (UINT32)SizeOfInfo, Info));
+                if (EFI_ERROR(Status) || Info == NULL) {
+                    continue;
+                }
+                DEBUG((DEBUG_INFO, "      Mode %u: %ux%u PPL=%u PixelFormat=%u\n",
+                       ModeNumber,
+                       (UINT32)Info->HorizontalResolution,
+                       (UINT32)Info->VerticalResolution,
+                       (UINT32)Info->PixelsPerScanLine,
+                       (UINT32)Info->PixelFormat));
+                gBS->FreePool(Info);
+            }
+        }
+    }
+
+    if (HandleBuffer != NULL) {
+        gBS->FreePool(HandleBuffer);
+        DEBUG((DEBUG_INFO, "ScanGop: Freed HandleBuffer %p\n", HandleBuffer));
+    }
+
+    return EFI_SUCCESS;
+}
+
+/*
+ * Bits per pixel selector. Each value n is such that the bits-per-pixel is
+ * 2 ^ n
+ */
+enum video_log2_bpp {
+  VIDEO_BPP1 = 0,
+  VIDEO_BPP2,
+  VIDEO_BPP4,
+  VIDEO_BPP8,
+  VIDEO_BPP16,
+  VIDEO_BPP32,
+};
+
+typedef struct {
+  VENDOR_DEVICE_PATH DisplayDevicePath;
+  EFI_DEVICE_PATH    EndDevicePath;
+} DISPLAY_DEVICE_PATH;
+
+DISPLAY_DEVICE_PATH mDisplayDevicePath = {
+    {{HARDWARE_DEVICE_PATH,
+      HW_VENDOR_DP,
+      {
+          (UINT8)(sizeof(VENDOR_DEVICE_PATH)),
+          (UINT8)((sizeof(VENDOR_DEVICE_PATH)) >> 8),
+      }},
+     EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID},
+    {END_DEVICE_PATH_TYPE,
+     END_ENTIRE_DEVICE_PATH_SUBTYPE,
+     {sizeof(EFI_DEVICE_PATH_PROTOCOL), 0}}};
+
+/// Declares
+
+STATIC FRAME_BUFFER_CONFIGURE *mFrameBufferBltLibConfigure;
+STATIC UINTN mFrameBufferBltLibConfigureSize;
+
+STATIC
+EFI_STATUS
+EFIAPI
+DisplayQueryMode(
+    IN EFI_GRAPHICS_OUTPUT_PROTOCOL *This, IN UINT32 ModeNumber,
+    OUT UINTN *SizeOfInfo, OUT EFI_GRAPHICS_OUTPUT_MODE_INFORMATION **Info);
+
+STATIC
+EFI_STATUS
+EFIAPI
+DisplaySetMode(IN EFI_GRAPHICS_OUTPUT_PROTOCOL *This, IN UINT32 ModeNumber);
+
+STATIC
+EFI_STATUS
+EFIAPI
+DisplayBlt(
+    IN EFI_GRAPHICS_OUTPUT_PROTOCOL *This,
+    IN EFI_GRAPHICS_OUTPUT_BLT_PIXEL *BltBuffer,
+    OPTIONAL IN EFI_GRAPHICS_OUTPUT_BLT_OPERATION BltOperation,
+    IN UINTN SourceX, IN UINTN SourceY, IN UINTN DestinationX,
+    IN UINTN DestinationY, IN UINTN Width, IN UINTN Height,
+    IN UINTN Delta OPTIONAL);
+
+STATIC EFI_GRAPHICS_OUTPUT_PROTOCOL mDisplay = {
+    DisplayQueryMode, DisplaySetMode, DisplayBlt, NULL};
+
+STATIC EFI_HANDLE mDisplayHandle = NULL;
+
+STATIC
+EFI_STATUS
+EFIAPI
+LocateExistingDisplayHandle(OUT EFI_HANDLE *DisplayHandle)
+{
+    EFI_STATUS  Status = EFI_NOT_FOUND;
+    EFI_HANDLE *HandleBuffer = NULL;
+    UINTN       HandleCount  = 0;
+    UINTN       Index;
+
+    Status = gBS->LocateHandleBuffer(
+            ByProtocol, &gEfiDevicePathProtocolGuid, NULL, &HandleCount,
+            &HandleBuffer);
+    if (EFI_ERROR(Status)) {
+        return Status;
+    }
+
+    for (Index = 0; Index < HandleCount; ++Index) {
+        EFI_DEVICE_PATH_PROTOCOL *DevicePath = NULL;
+        Status                               = gBS->HandleProtocol(
+                HandleBuffer[Index], &gEfiDevicePathProtocolGuid,
+                (VOID **)&DevicePath);
+        if (EFI_ERROR(Status) || DevicePath == NULL) {
+            continue;
+        }
+
+        if (CompareMem(
+                        DevicePath, &mDisplayDevicePath, sizeof(mDisplayDevicePath)) == 0) {
+            *DisplayHandle = HandleBuffer[Index];
+            Status         = EFI_SUCCESS;
+            break;
+        }
+    }
+
+    if (HandleBuffer != NULL) {
+        gBS->FreePool(HandleBuffer);
+    }
+
+    return Status;
+}
+
+STATIC
+EFI_STATUS
+EFIAPI
+DisplayQueryMode(
+    IN EFI_GRAPHICS_OUTPUT_PROTOCOL *This, IN UINT32 ModeNumber,
+    OUT UINTN *SizeOfInfo, OUT EFI_GRAPHICS_OUTPUT_MODE_INFORMATION **Info)
+{
+  EFI_STATUS Status;
+  Status = gBS->AllocatePool(
+      EfiBootServicesData, sizeof(EFI_GRAPHICS_OUTPUT_MODE_INFORMATION),
+      (VOID **)Info);
+
+  ASSERT_EFI_ERROR(Status);
+
+  *SizeOfInfo                   = sizeof(EFI_GRAPHICS_OUTPUT_MODE_INFORMATION);
+  (*Info)->Version              = This->Mode->Info->Version;
+  (*Info)->HorizontalResolution = This->Mode->Info->HorizontalResolution;
+  (*Info)->VerticalResolution   = This->Mode->Info->VerticalResolution;
+  (*Info)->PixelFormat          = This->Mode->Info->PixelFormat;
+  (*Info)->PixelsPerScanLine    = This->Mode->Info->PixelsPerScanLine;
+
+  return EFI_SUCCESS;
+}
+
+STATIC
+EFI_STATUS
+EFIAPI
+DisplaySetMode(IN EFI_GRAPHICS_OUTPUT_PROTOCOL *This, IN UINT32 ModeNumber)
+{
+  return EFI_SUCCESS;
+}
+
+STATIC
+EFI_STATUS
+EFIAPI
+DisplayBlt(
+    IN EFI_GRAPHICS_OUTPUT_PROTOCOL *This,
+    IN EFI_GRAPHICS_OUTPUT_BLT_PIXEL *BltBuffer,
+    OPTIONAL IN EFI_GRAPHICS_OUTPUT_BLT_OPERATION BltOperation,
+    IN UINTN SourceX, IN UINTN SourceY, IN UINTN DestinationX,
+    IN UINTN DestinationY, IN UINTN Width, IN UINTN Height,
+    IN UINTN Delta OPTIONAL)
+{
+  RETURN_STATUS Status;
+  EFI_TPL       Tpl;
+  //
+  // We have to raise to TPL_NOTIFY, so we make an atomic write to the frame
+  // buffer. We would not want a timer based event (Cursor, ...) to come in
+  // while we are doing this operation.
+  //
+  Tpl    = gBS->RaiseTPL(TPL_NOTIFY);
+  Status = FrameBufferBlt(
+      mFrameBufferBltLibConfigure, BltBuffer, BltOperation, SourceX, SourceY,
+      DestinationX, DestinationY, Width, Height, Delta);
+  gBS->RestoreTPL(Tpl);
+
+  return RETURN_ERROR(Status) ? EFI_INVALID_PARAMETER : EFI_SUCCESS;
+}
+
+// UninstallGop: uninstall the GOP protocol from the first discovered handle
+STATIC EFI_STATUS
+UninstallGop(VOID)
+{
+    EFI_STATUS Status;
+    EFI_HANDLE *HandleBuffer = NULL;
+    UINTN HandleCount = 0;
+    EFI_HANDLE TargetHandle = NULL;
+    EFI_GRAPHICS_OUTPUT_PROTOCOL *Gop = NULL;
+
+    Status = gBS->LocateHandleBuffer(ByProtocol, &gEfiGraphicsOutputProtocolGuid, NULL, &HandleCount, &HandleBuffer);
+    DEBUG((DEBUG_INFO, "UninstallGop: LocateHandleBuffer returned %r, HandleCount=%u\n", Status, HandleCount));
+    if (EFI_ERROR(Status) || HandleCount == 0) {
+        if (HandleBuffer != NULL) {
+            gBS->FreePool(HandleBuffer);
+        }
+        return EFI_NOT_FOUND;
+    }
+
+    TargetHandle = HandleBuffer[0];
+    Status = gBS->HandleProtocol(TargetHandle, &gEfiGraphicsOutputProtocolGuid, (VOID **)&Gop);
+    DEBUG((DEBUG_INFO, "UninstallGop: HandleProtocol returned %r, Gop=%p\n", Status, Gop));
+    if (EFI_ERROR(Status) || Gop == NULL) {
+        if (HandleBuffer != NULL) {
+            gBS->FreePool(HandleBuffer);
+        }
+        return EFI_NOT_FOUND;
+    }
+
+    if (Gop == &mDisplay) {
+        mDisplayHandle = TargetHandle;
+    }
+
+    Status = gBS->UninstallProtocolInterface(TargetHandle, &gEfiGraphicsOutputProtocolGuid, Gop);
+    DEBUG((DEBUG_INFO, "UninstallGop: UninstallProtocolInterface returned %r\n", Status));
+
+    if (HandleBuffer != NULL) {
+        gBS->FreePool(HandleBuffer);
+    }
+
+    return Status;
+}
+
+EFI_STATUS
+EFIAPI
+SimpleFbDxeEntry(
+  OUT EFI_PHYSICAL_ADDRESS *MipiFrameBufferAddr
+)
+{
+
+  EFI_STATUS Status             = EFI_SUCCESS;
+  EFI_HANDLE hUEFIDisplayHandle = NULL;
+
+  UINT32 MipiFrameBufferWidth  = FixedPcdGet32(PcdMipiFrameBufferWidth);
+  UINT32 MipiFrameBufferHeight = FixedPcdGet32(PcdMipiFrameBufferHeight);
+
+  if(0 == FixedPcdGet32(PcdDefaultGopRotation)){
+    // TODO: get from memory map
+    *MipiFrameBufferAddr = FixedPcdGet32(PcdMipiFrameBufferHardwareBase);
+  } else {
+    /* Allocate aligned memory for fake framebuffer */
+    Status = gBS->AllocatePages(
+            AllocateAnyPages,
+            EfiBootServicesData,
+            EFI_SIZE_TO_PAGES(MipiFrameBufferWidth * MipiFrameBufferHeight * FB_BYTES_PER_PIXEL),
+            MipiFrameBufferAddr);
+
+    if (EFI_ERROR(Status) || *MipiFrameBufferAddr == 0) {
+        DEBUG((EFI_D_ERROR, "SimpleFbDxe: Failed to allocate fake framebuffer: %r\n", Status));
+        return Status;
+    }
+  }
+
+  /* Sanity check */
+  if (*MipiFrameBufferAddr == 0 || MipiFrameBufferWidth == 0 ||
+      MipiFrameBufferHeight == 0) {
+    DEBUG((EFI_D_ERROR, "SimpleFbDxe: Invalid FrameBuffer parameters\n"));
+    return EFI_DEVICE_ERROR;
+  }
+
+  /* Prepare struct */
+  if (mDisplay.Mode == NULL) {
+    Status = gBS->AllocatePool(
+        EfiBootServicesData, sizeof(EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE),
+        (VOID **)&mDisplay.Mode);
+
+    ASSERT_EFI_ERROR(Status);
+    if (EFI_ERROR(Status))
+      return Status;
+
+    ZeroMem(mDisplay.Mode, sizeof(EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE));
+  }
+
+  if (mDisplay.Mode->Info == NULL) {
+    Status = gBS->AllocatePool(
+        EfiBootServicesData, sizeof(EFI_GRAPHICS_OUTPUT_MODE_INFORMATION),
+        (VOID **)&mDisplay.Mode->Info);
+
+    ASSERT_EFI_ERROR(Status);
+    if (EFI_ERROR(Status))
+      return Status;
+
+    ZeroMem(mDisplay.Mode->Info, sizeof(EFI_GRAPHICS_OUTPUT_MODE_INFORMATION));
+  }
+
+  /* Set information */
+  mDisplay.Mode->MaxMode       = 1;
+  mDisplay.Mode->Mode          = 0;
+  mDisplay.Mode->Info->Version = 0;
+
+  mDisplay.Mode->Info->HorizontalResolution = MipiFrameBufferWidth;
+  mDisplay.Mode->Info->VerticalResolution   = MipiFrameBufferHeight;
+
+  /* SimpleFB runs on a8r8g8b8 (VIDEO_BPP32) for WoA devices */
+  UINT32               LineLength = MipiFrameBufferWidth * VNBYTES(VIDEO_BPP32);
+  UINT32               FrameBufferSize    = LineLength * MipiFrameBufferHeight;
+  EFI_PHYSICAL_ADDRESS FrameBufferAddress = *MipiFrameBufferAddr;
+
+  mDisplay.Mode->Info->PixelsPerScanLine = MipiFrameBufferWidth;
+  mDisplay.Mode->Info->PixelFormat = PixelBlueGreenRedReserved8BitPerColor;
+  mDisplay.Mode->SizeOfInfo      = sizeof(EFI_GRAPHICS_OUTPUT_MODE_INFORMATION);
+  mDisplay.Mode->FrameBufferBase = FrameBufferAddress;
+  mDisplay.Mode->FrameBufferSize = FrameBufferSize;
+
+  /* Create the FrameBufferBltLib configuration. */
+  Status = FrameBufferBltConfigure(
+      (VOID *)(UINTN)mDisplay.Mode->FrameBufferBase, mDisplay.Mode->Info,
+      mFrameBufferBltLibConfigure, &mFrameBufferBltLibConfigureSize);
+
+  if (Status == RETURN_BUFFER_TOO_SMALL) {
+    mFrameBufferBltLibConfigure = AllocatePool(mFrameBufferBltLibConfigureSize);
+    if (mFrameBufferBltLibConfigure != NULL) {
+      Status = FrameBufferBltConfigure(
+          (VOID *)(UINTN)mDisplay.Mode->FrameBufferBase, mDisplay.Mode->Info,
+          mFrameBufferBltLibConfigure, &mFrameBufferBltLibConfigureSize);
+    }
+  }
+
+  ASSERT_EFI_ERROR(Status);
+  ZeroMem((VOID *)FrameBufferAddress, FrameBufferSize);
+
+  /* Register handle */
+  Status = gBS->InstallMultipleProtocolInterfaces(
+            (mDisplayHandle == NULL) ? &hUEFIDisplayHandle : &mDisplayHandle,
+            &gEfiDevicePathProtocolGuid, &mDisplayDevicePath,
+            &gEfiGraphicsOutputProtocolGuid, &mDisplay, NULL);
+
+    if (Status == EFI_ALREADY_STARTED) {
+        EFI_HANDLE ExistingHandle = mDisplayHandle;
+
+        if (ExistingHandle == NULL) {
+            Status = LocateExistingDisplayHandle(&ExistingHandle);
+            if (EFI_ERROR(Status)) {
+                goto InstallExit;
+            }
+        }
+
+        Status = gBS->InstallProtocolInterface(
+                &ExistingHandle, &gEfiGraphicsOutputProtocolGuid, EFI_NATIVE_INTERFACE,
+                &mDisplay);
+
+        if (Status == EFI_ALREADY_STARTED) {
+            Status = EFI_SUCCESS;
+        }
+
+        if (!EFI_ERROR(Status)) {
+            mDisplayHandle = ExistingHandle;
+        }
+    } else if (!EFI_ERROR(Status)) {
+        mDisplayHandle = (mDisplayHandle == NULL) ? hUEFIDisplayHandle : mDisplayHandle;
+    }
+
+InstallExit:
+    ASSERT_EFI_ERROR(Status);
+
+  return Status;
+}
+
+EFI_STATUS
+EFIAPI
+GopFBRotateEntryPoint (
+    IN EFI_HANDLE        ImageHandle,
+    IN EFI_SYSTEM_TABLE  *SystemTable
+    )
+{
+    EFI_STATUS Status = EFI_SUCCESS;
+    EFI_PHYSICAL_ADDRESS FakeFrameBufferAddr = 0;
+
+    DEBUG((DEBUG_INFO, "GopFBRotateEntryPoint: ImageHandle=%p, SystemTable=%p\n", ImageHandle, SystemTable));
+
+    Status = ScanGop();
+    if (EFI_ERROR(Status)) {
+        DEBUG((DEBUG_WARN, "ScanGop returned %r\n", Status));
+    }
+
+    Status = UninstallGop();
+    if (EFI_ERROR(Status)) {
+        DEBUG((DEBUG_WARN, "UninstallGop returned %r, continuing\n", Status));
+    } else {
+        DEBUG((DEBUG_INFO, "UninstallGop succeeded\n"));
+    }
+
+    Status = ScanGop();
+    if (EFI_ERROR(Status)) {
+        DEBUG((DEBUG_WARN, "ScanGop after UninstallGop returned %r\n", Status));
+    }
+
+    Status = SimpleFbDxeEntry(&FakeFrameBufferAddr);
+
+    if (EFI_ERROR(Status)) {
+        DEBUG((DEBUG_ERROR, "SimpleFbDxeEntry failed: %r\n", Status));
+        return Status;
+    }
+
+    Status = ScanGop();
+    if (EFI_ERROR(Status)) {
+        DEBUG((DEBUG_WARN, "ScanGop after InstallSimpleGop returned %r\n", Status));
+    }
+
+    Status = StartRotateTask(
+        FakeFrameBufferAddr,
+        FixedPcdGet32(PcdMipiFrameBufferHardwareBase)
+    );
+
+    DEBUG((DEBUG_INFO, "GopFBRotate sequence complete\n"));
+    return EFI_SUCCESS;
+}
diff --git a/QcomModulePkg/Driver/GopFBRotate/GopFBRotate.inf b/QcomModulePkg/Driver/GopFBRotate/GopFBRotate.inf
new file mode 100644
index 00000000..bd1f89a6
--- /dev/null
+++ b/QcomModulePkg/Driver/GopFBRotate/GopFBRotate.inf
@@ -0,0 +1,49 @@
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = GopFBRotate
+  FILE_GUID                      = 5504da8e-3cc1-491e-a8f1-6624bbbff1a8
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = GopFBRotateEntryPoint
+
+# The following information is for reference only and not required by the build tools.
+#  VALID_ARCHITECTURES           = AARCH64
+
+[Sources]
+  GopFBRotate.c
+
+[Packages]
+  ArmPkg/ArmPkg.dec
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  QcomModulePkg/QcomModulePkg.dec
+
+[LibraryClasses]
+  BaseLib
+  UefiBootServicesTableLib
+  DebugLib
+  UefiLib
+  IoLib
+  UefiDriverEntryPoint
+  PcdLib
+  BootLib
+  StackCanary
+  FrameBufferBltLib
+
+[Guids]
+
+[Pcd]
+  gQcomTokenSpaceGuid.PcdDefaultGopRotation
+  gQcomTokenSpaceGuid.PcdMipiFrameBufferWidth
+  gQcomTokenSpaceGuid.PcdMipiFrameBufferHeight
+  gQcomTokenSpaceGuid.PcdMipiFrameBufferHardwareBase
+
+[Protocols]
+  gEfiGraphicsOutputProtocolGuid                ## CONSUMES
+  gEfiDevicePathProtocolGuid                    ## CONSUMES
+
+[Depex]
+  TRUE
+
+[BuildOptions]
+  GCC:*_*_*_CC_FLAGS = -march=armv8.7-a+simd -O3 -ffast-math -flto
diff --git a/QcomModulePkg/QcomModulePkg.dec b/QcomModulePkg/QcomModulePkg.dec
index aaa4dbef..26d40287 100644
--- a/QcomModulePkg/QcomModulePkg.dec
+++ b/QcomModulePkg/QcomModulePkg.dec
@@ -181,3 +181,11 @@
   gQcomTokenSpaceGuid.EnableDdrRegion|TRUE|BOOLEAN|0x0001500D
   gQcomTokenSpaceGuid.EnableUpdateRankChannel|FALSE|BOOLEAN|0x0001500E
   gQcomTokenSpaceGuid.EnableForceBootAlternateSlot|TRUE|BOOLEAN|0x0001500F
+
+  # Framebuffer driver needed
+  # Set default value here for different devices
+  # Note: Width and Height are the h/v after rotated.
+  gQcomTokenSpaceGuid.PcdDefaultGopRotation|1|UINT32|0x00016001
+  gQcomTokenSpaceGuid.PcdMipiFrameBufferWidth|2560|UINT32|0x00016002
+  gQcomTokenSpaceGuid.PcdMipiFrameBufferHeight|1440|UINT32|0x00016003
+  gQcomTokenSpaceGuid.PcdMipiFrameBufferHardwareBase|0xD5100000|UINT32|0x00016004
diff --git a/QcomModulePkg/QcomModulePkg.dsc b/QcomModulePkg/QcomModulePkg.dsc
index 275d50cb..7c3eb7c4 100644
--- a/QcomModulePkg/QcomModulePkg.dsc
+++ b/QcomModulePkg/QcomModulePkg.dsc
@@ -259,3 +259,12 @@
 			Lz4Lib|QcomModulePkg/Library/lz4/lib/Lz4Lib.inf
             LoadFVLib|QcomModulePkg/Library/LoadFVLib/LoadFVLib.inf
 	}
+
+    QcomModulePkg/Driver/GopFBRotate/GopFBRotate.inf {
+        <LibraryClasses>
+            BootLib|QcomModulePkg/Library/BootLib/BootLib.inf
+            StackCanary|QcomModulePkg/Library/StackCanary/StackCanary.inf
+            UbsanLib|QcomModulePkg/Library/UbsanLib/UbsanLib.inf
+            FrameBufferBltLib|MdeModulePkg/Library/FrameBufferBltLib/FrameBufferBltLib.inf
+            BaseMemoryLib|MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf
+    }
diff --git a/QcomModulePkg/QcomModulePkg.fdf b/QcomModulePkg/QcomModulePkg.fdf
index 999f6804..16e7915d 100755
--- a/QcomModulePkg/QcomModulePkg.fdf
+++ b/QcomModulePkg/QcomModulePkg.fdf
@@ -144,6 +144,7 @@ READ_LOCK_STATUS   = TRUE
 FvNameGuid         = 046fae99-cf2e-49ed-a6a8-a1488b7e80d3
 
 INF QcomModulePkg/Application/LinuxLoader/LinuxLoader.inf
+INF QcomModulePkg/Driver/GopFBRotate/GopFBRotate.inf
 
 [FV.FVMAIN_COMPACT]
 FvAlignment        = 8
-- 
2.43.0

