From 5f250bc2c30cac015cdd1f2ba26dac502ebdde0d Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Thu, 4 Dec 2025 10:50:41 +0000
Subject: [PATCH 05/13] add esp load option in fastboot menu

---
 QcomModulePkg/Include/Library/BootESP.h       |  11 +
 QcomModulePkg/Include/Library/DrawUI.h        |   1 +
 QcomModulePkg/Library/BootLib/BootESP.c       | 282 ++++++++++++++++++
 QcomModulePkg/Library/BootLib/BootLib.inf     |   4 +
 QcomModulePkg/Library/BootLib/FastbootMenu.c  | 136 +++++----
 .../Library/BootLib/MenuKeysDetection.c       |   6 +
 6 files changed, 377 insertions(+), 63 deletions(-)
 create mode 100644 QcomModulePkg/Include/Library/BootESP.h
 create mode 100644 QcomModulePkg/Library/BootLib/BootESP.c

diff --git a/QcomModulePkg/Include/Library/BootESP.h b/QcomModulePkg/Include/Library/BootESP.h
new file mode 100644
index 0000000000..a5e77e6349
--- /dev/null
+++ b/QcomModulePkg/Include/Library/BootESP.h
@@ -0,0 +1,11 @@
+#ifndef __BOOTESP_H__
+#define __BOOTESP_H__
+
+#include <Uefi.h>
+#include <Library/BaseLib.h>
+
+EFI_STATUS
+EFIAPI
+BootESP (VOID);
+
+#endif // __BOOTESP_H__
\ No newline at end of file
diff --git a/QcomModulePkg/Include/Library/DrawUI.h b/QcomModulePkg/Include/Library/DrawUI.h
index b18a5b847c..5c825ee3e4 100644
--- a/QcomModulePkg/Include/Library/DrawUI.h
+++ b/QcomModulePkg/Include/Library/DrawUI.h
@@ -151,6 +151,7 @@ typedef enum {
   QMMI,
   ALTERNATESLOT,
   NOACTION,
+  ESP,
   OPTION_ACTION_MAX,
 } OPTION_ITEM_ACTION;
 
diff --git a/QcomModulePkg/Library/BootLib/BootESP.c b/QcomModulePkg/Library/BootLib/BootESP.c
new file mode 100644
index 0000000000..5d6b05b4aa
--- /dev/null
+++ b/QcomModulePkg/Library/BootLib/BootESP.c
@@ -0,0 +1,282 @@
+/**
+  BootESP - load and start \EFI\BOOT\BOOTAA64.EFI from any mounted FS.
+
+  This function is intended to be called from ABL to transfer control
+  to the ESP boot loader. It performs the following high-level steps:
+  - Connect all controllers so that file systems are available
+  - Signal a few firmware GUID events (Detect SD, ReadyToBoot, EndOfDxe)
+  - Search all SimpleFileSystem volumes for "\\EFI\\BOOT\\BOOTAA64.EFI"
+  - Call LoadImage/StartImage directly using a synthesized device path
+
+*/
+#include <Library/BaseLib.h>
+#include <Library/BootESP.h>
+#include <Library/DebugLib.h>
+#include <Library/DevicePathLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiLib.h>
+#include <Uefi.h>
+
+#include <Guid/EventGroup.h>
+#include <Protocol/DevicePath.h>
+#include <Protocol/EFIDisplayPwr.h>
+#include <Protocol/SimpleFileSystem.h>
+#include <Library/MenuKeysDetection.h>
+#include <Library/FastbootMenu.h>
+
+STATIC CONST CHAR16 BootA64Path[] = L"\\EFI\\BOOT\\BOOTAA64.EFI";
+STATIC CONST EFI_GUID gEfiEventDetectSDCardGuid = {
+    0xb7972c36,
+    0x8a4c,
+    0x4a56,
+    {0x8b, 0x02, 0x11, 0x59, 0xb5, 0x2d, 0x4b, 0xfb}};
+
+STATIC EFI_DISPLAY_POWER_PROTOCOL *mDisplayPowerProtocol = NULL;
+
+// Initialize the Display Power Protocol if available
+STATIC
+VOID
+InitializeDisplayPowerProtocol (VOID)
+{
+  EFI_STATUS Status;
+
+  mDisplayPowerProtocol = NULL;
+  Status = gBS->LocateProtocol (&gEfiDisplayPowerStateProtocolGuid, NULL,
+                                (VOID **)&mDisplayPowerProtocol);
+  if (EFI_ERROR (Status) || mDisplayPowerProtocol == NULL) {
+    DEBUG ((DEBUG_INFO,
+            "InitializeDisplayPowerProtocol: no display power protocol: %r\n",
+            Status));
+    mDisplayPowerProtocol = NULL;
+    return;
+  }
+
+  // query current state and try a test set to ensure it's usable
+  EFI_DISPLAY_POWER_STATE CurState = EfiDisplayPowerStateUnknown;
+  Status = mDisplayPowerProtocol->GetDisplayPowerState (mDisplayPowerProtocol,
+                                                        &CurState);
+  if (!EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_INFO, "InitializeDisplayPowerProtocol: current state=%d\n",
+            CurState));
+    // Try to set On briefly to validate Set function (ignore errors)
+    (void)mDisplayPowerProtocol->SetDisplayPowerState (mDisplayPowerProtocol,
+                                                       EfiDisplayPowerStateOn);
+  }
+}
+
+// ExitBootServices notify callback to turn display off
+STATIC
+VOID EFIAPI
+DisableDisplayOnExitBootServices (IN EFI_EVENT Event, IN VOID *Context)
+{
+  if (mDisplayPowerProtocol != NULL) {
+    (void)mDisplayPowerProtocol->SetDisplayPowerState (mDisplayPowerProtocol,
+                                                       EfiDisplayPowerStateOff);
+  }
+}
+
+// Register callback for ExitBootServices to disable display
+STATIC
+VOID
+RegisterExitBootServicesDisplayCallback (VOID)
+{
+  EFI_STATUS Status;
+  EFI_EVENT Event = NULL;
+
+  Status = gBS->CreateEvent (EVT_SIGNAL_EXIT_BOOT_SERVICES, TPL_CALLBACK,
+                             DisableDisplayOnExitBootServices, NULL, &Event);
+  if (EFI_ERROR (Status) || Event == NULL) {
+    DEBUG ((DEBUG_INFO,
+            "RegisterExitBootServicesDisplayCallback: CreateEvent failed: %r\n",
+            Status));
+    return;
+  }
+
+  // keep event open so it fires at ExitBootServices
+  DEBUG ((DEBUG_INFO, "RegisterExitBootServicesDisplayCallback: registered\n"));
+}
+
+// Connect all handles/controllers so file systems become available
+STATIC
+VOID
+ConnectAllControllers (VOID)
+{
+  EFI_STATUS Status;
+  EFI_HANDLE *Handles = NULL;
+  UINTN HandleCount = 0;
+
+  Status =
+      gBS->LocateHandleBuffer (AllHandles, NULL, NULL, &HandleCount, &Handles);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_INFO,
+            "ConnectAllControllers: no handles found or LocateHandleBuffer "
+            "failed: %r\n",
+            Status));
+    return;
+  }
+
+  for (UINTN i = 0; i < HandleCount; i++) {
+    (void)gBS->ConnectController (Handles[i], NULL, NULL, TRUE);
+  }
+
+  gBS->FreePool (Handles);
+}
+
+// Create and signal a simple event-ex (notify-signal) for the given GUID
+STATIC
+VOID EFIAPI
+SignalGuidEventCallback (IN EFI_EVENT Event, IN VOID *Context)
+{
+  DEBUG ((EFI_D_INFO, "SignalGuidEventCallback: signaled event\n"));
+  return;
+}
+
+STATIC
+VOID
+SignalGuidEvent (CONST EFI_GUID *EventGuid)
+{
+  EFI_STATUS Status;
+  EFI_EVENT Event = NULL;
+
+  Status =
+      gBS->CreateEventEx (EVT_NOTIFY_SIGNAL, TPL_CALLBACK,
+                          SignalGuidEventCallback, NULL, EventGuid, &Event);
+  if (EFI_ERROR (Status) || Event == NULL) {
+    DEBUG ((DEBUG_INFO, "SignalGuidEvent: CreateEventEx failed for %g: %r\n",
+            EventGuid, Status));
+    return;
+  }
+
+  gBS->SignalEvent (Event);
+  gBS->CloseEvent (Event);
+}
+
+// Try to find and load BOOTAA64 from any simple file system.
+STATIC
+EFI_STATUS
+EFIAPI
+LoadBootA64AndStart()
+{
+  EFI_STATUS Status;
+  EFI_HANDLE *Handles = NULL;
+  UINTN HandleCount = 0;
+  UINTN Idx;
+  gBS->RestoreTPL (TPL_APPLICATION);
+
+  DEBUG((DEBUG_INFO, "LoadBootA64AndStart: try find bootable image\n"));
+  
+  Status =
+      gBS->LocateHandleBuffer (ByProtocol, &gEfiSimpleFileSystemProtocolGuid,
+                               NULL, &HandleCount, &Handles);
+  if (EFI_ERROR (Status) || HandleCount == 0 || Handles == NULL) {
+    DEBUG ((DEBUG_INFO,
+            "LoadBootA64AndStart: no SimpleFileSystem handles: %r\n", Status));
+    return EFI_NOT_FOUND;
+  }
+
+  for (Idx = 0; Idx < HandleCount; Idx++) {
+    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *Fs = NULL;
+    EFI_FILE_PROTOCOL *Root = NULL;
+    EFI_FILE_PROTOCOL *File = NULL;
+    EFI_DEVICE_PATH_PROTOCOL *BootFileDevicePath = NULL;
+    EFI_HANDLE ImageHandle = NULL;
+
+    Status = gBS->HandleProtocol (
+        Handles[Idx], &gEfiSimpleFileSystemProtocolGuid, (VOID **)&Fs);
+    if (EFI_ERROR (Status) || (Fs == NULL)) {
+      continue;
+    }
+
+    Status = Fs->OpenVolume (Fs, &Root);
+    if (EFI_ERROR (Status) || (Root == NULL)) {
+      continue;
+    }
+
+    Status =
+        Root->Open (Root, &File, (CHAR16 *)BootA64Path, EFI_FILE_MODE_READ, 0);
+    if (EFI_ERROR (Status) || (File == NULL)) {
+      Root->Close (Root);
+      Root = NULL;
+      continue;
+    }
+
+    File->Close (File);
+    File = NULL;
+    Root->Close (Root);
+    Root = NULL;
+
+    BootFileDevicePath = FileDevicePath (Handles[Idx], BootA64Path);
+    if (BootFileDevicePath == NULL) {
+      DEBUG ((DEBUG_INFO, "LoadBootA64AndStart: FileDevicePath failed\n"));
+      continue;
+    }
+
+    // Use BootPolicy = TRUE to leverage firmware Boot Manager heuristics
+    Status = gBS->LoadImage (FALSE, gImageHandle, BootFileDevicePath, NULL, 0,
+                             &ImageHandle);
+    if (EFI_ERROR (Status)) {
+      DEBUG (
+          (DEBUG_INFO, "LoadBootA64AndStart: LoadImage failed: %r\n", Status));
+      FreePool (BootFileDevicePath);
+      continue;
+    }
+
+    Status = gBS->StartImage (ImageHandle, NULL, NULL);
+    if (EFI_ERROR (Status)) {
+      DEBUG ((DEBUG_INFO, "LoadBootA64AndStart: StartImage failed: %r\n", Status));
+      (VOID) gBS->UnloadImage (ImageHandle);
+      FreePool (BootFileDevicePath);
+      goto free;
+    }
+
+    FreePool (BootFileDevicePath);
+    goto free;
+  }
+
+free:
+  gBS->FreePool (Handles);
+  return Status;
+}
+
+/**
+  Entry point called from ABL to boot ESP image.
+*/
+EFI_STATUS
+EFIAPI
+BootESP (VOID)
+{
+  EFI_STATUS Status = EFI_SUCCESS;
+  ExitMenuKeysDetection();
+  // Backup Current TPL
+  EFI_TPL CurrentTPL = gBS->RaiseTPL (TPL_HIGH_LEVEL);
+  // Reduce TPL to Application for further operations
+  gBS->RestoreTPL (TPL_APPLICATION);
+
+  // Only Register & Signal once
+  STATIC BOOLEAN FirstCall = TRUE;
+  if (FirstCall) {
+    FirstCall = FALSE;
+    // Initialize display protocol and register ExitBootServices callback
+    InitializeDisplayPowerProtocol ();
+    RegisterExitBootServicesDisplayCallback ();
+
+    SignalGuidEvent (&gEfiEventReadyToBootGuid);
+    SignalGuidEvent (&gEfiEndOfDxeEventGroupGuid);
+  }
+
+  // Signal a few well-known GUID events
+  SignalGuidEvent (&gEfiEventDetectSDCardGuid);
+  ConnectAllControllers ();
+
+  // Load and start BOOTAA64.EFI
+  Status = LoadBootA64AndStart ();
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "BootESP: LoadBootA64AndStart failed: %r\n", Status));
+  }
+
+  // Restore original TPL
+  gBS->RaiseTPL (CurrentTPL);
+  DisplayFastbootMenu ();
+  return Status;
+}
diff --git a/QcomModulePkg/Library/BootLib/BootLib.inf b/QcomModulePkg/Library/BootLib/BootLib.inf
index e6c4f1589b..5659981c35 100644
--- a/QcomModulePkg/Library/BootLib/BootLib.inf
+++ b/QcomModulePkg/Library/BootLib/BootLib.inf
@@ -84,6 +84,7 @@
 	ShutdownServices.c
 	Board.c
 	BootLinux.c
+	BootESP.c
 	Decompress.c
 	LocateDeviceTree.c
 	UpdateDeviceTree.c
@@ -146,6 +147,9 @@
 	gEfiFileInfoGuid
 	gEfiSdRemovableGuid
 	gEfiFileSystemInfoGuid
+	gEfiEventExitBootServicesGuid
+	gEfiEventReadyToBootGuid
+	gEfiEndOfDxeEventGroupGuid
 	gEfiPartitionTypeGuid
 	gEfiEmmcRpmbPartitionGuid
 	gEfiEmmcGppPartition1Guid
diff --git a/QcomModulePkg/Library/BootLib/FastbootMenu.c b/QcomModulePkg/Library/BootLib/FastbootMenu.c
index 53189b091c..7a950e36ec 100644
--- a/QcomModulePkg/Library/BootLib/FastbootMenu.c
+++ b/QcomModulePkg/Library/BootLib/FastbootMenu.c
@@ -88,6 +88,13 @@ STATIC MENU_MSG_INFO mFastbootOptionTitle[] = {
      OPTION_ITEM,
      0,
      RESTART},
+    {{"Boot to ESP"},
+     BIG_FACTOR,
+     BGR_CYAN,
+     BGR_BLACK,
+     OPTION_ITEM,
+     0,
+     ESP},
     {{"Restart bootloader"},
      BIG_FACTOR,
      BGR_RED,
@@ -371,77 +378,80 @@ FastbootMenuShowScreen (OPTION_MENU_INFO *OptionMenuInfo)
     return Status;
 
   /* Update fastboot common message */
+  STATIC BOOLEAN IsFastbootCommonMsgInit = FALSE;
+
   for (i = 0; i < ARRAY_SIZE (mFastbootCommonMsgInfo); i++) {
-    switch (i) {
-    case 0:
-      break;
-    case 1:
-      /* Get product name */
-      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
-        sizeof (mFastbootCommonMsgInfo[i].Msg), PRODUCT_NAME,
-        AsciiStrLen (PRODUCT_NAME));
-      break;
-    case 2:
-      /* Get variant value */
-      BoardHwPlatformName (StrTemp, sizeof (StrTemp));
-      GetRootDeviceType (StrTemp1, sizeof (StrTemp1));
-
-      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
-                     sizeof (mFastbootCommonMsgInfo[i].Msg), StrTemp,
-                     sizeof (StrTemp));
-      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
-                     sizeof (mFastbootCommonMsgInfo[i].Msg), " ",
-                     AsciiStrLen (" "));
-      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
-                     sizeof (mFastbootCommonMsgInfo[i].Msg), StrTemp1,
-                     sizeof (StrTemp1));
-      break;
-    case 3:
-      /* Get bootloader version */
-      GetBootloaderVersion (VersionTemp, sizeof (VersionTemp));
-      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
-                     sizeof (mFastbootCommonMsgInfo[i].Msg), VersionTemp,
-                     sizeof (VersionTemp));
-      break;
-    case 4:
-      /* Get baseband version */
-      ZeroMem (VersionTemp, sizeof (VersionTemp));
-      GetRadioVersion (VersionTemp, sizeof (VersionTemp));
-      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
-                     sizeof (mFastbootCommonMsgInfo[i].Msg), VersionTemp,
-                     sizeof (VersionTemp));
-      break;
-    case 5:
-      /* Get serial number */
-      ZeroMem (StrTemp, sizeof (StrTemp));
-      BoardSerialNum (StrTemp, MAX_RSP_SIZE);
-      AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
-                     sizeof (mFastbootCommonMsgInfo[i].Msg), StrTemp,
-                     sizeof (StrTemp));
-      break;
-    case 6:
-      /* Get secure boot value */
-      AsciiStrnCatS (
-          mFastbootCommonMsgInfo[i].Msg, sizeof (mFastbootCommonMsgInfo[i].Msg),
-          IsSecureBootEnabled () ? "yes" : "no",
-          IsSecureBootEnabled () ? AsciiStrLen ("yes") : AsciiStrLen ("no"));
-      break;
-    case 7:
-      /* Get device status */
-      AsciiStrnCatS (
-          mFastbootCommonMsgInfo[i].Msg, sizeof (mFastbootCommonMsgInfo[i].Msg),
-          IsUnlocked () ? "unlocked" : "locked",
-          IsUnlocked () ? AsciiStrLen ("unlocked") : AsciiStrLen ("locked"));
-      break;
+    if (!IsFastbootCommonMsgInit) {
+      switch (i) {
+      case 0:
+        break;
+      case 1:
+        /* Get product name */
+        AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
+          sizeof (mFastbootCommonMsgInfo[i].Msg), PRODUCT_NAME,
+          AsciiStrLen (PRODUCT_NAME));
+        break;
+      case 2:
+        /* Get variant value */
+        BoardHwPlatformName (StrTemp, sizeof (StrTemp));
+        GetRootDeviceType (StrTemp1, sizeof (StrTemp1));
+
+        AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
+                      sizeof (mFastbootCommonMsgInfo[i].Msg), StrTemp,
+                      sizeof (StrTemp));
+        AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
+                      sizeof (mFastbootCommonMsgInfo[i].Msg), " ",
+                      AsciiStrLen (" "));
+        AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
+                      sizeof (mFastbootCommonMsgInfo[i].Msg), StrTemp1,
+                      sizeof (StrTemp1));
+        break;
+      case 3:
+        /* Get bootloader version */
+        GetBootloaderVersion (VersionTemp, sizeof (VersionTemp));
+        AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
+                      sizeof (mFastbootCommonMsgInfo[i].Msg), VersionTemp,
+                      sizeof (VersionTemp));
+        break;
+      case 4:
+        /* Get baseband version */
+        ZeroMem (VersionTemp, sizeof (VersionTemp));
+        GetRadioVersion (VersionTemp, sizeof (VersionTemp));
+        AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
+                      sizeof (mFastbootCommonMsgInfo[i].Msg), VersionTemp,
+                      sizeof (VersionTemp));
+        break;
+      case 5:
+        /* Get serial number */
+        ZeroMem (StrTemp, sizeof (StrTemp));
+        BoardSerialNum (StrTemp, MAX_RSP_SIZE);
+        AsciiStrnCatS (mFastbootCommonMsgInfo[i].Msg,
+                      sizeof (mFastbootCommonMsgInfo[i].Msg), StrTemp,
+                      sizeof (StrTemp));
+        break;
+      case 6:
+        /* Get secure boot value */
+        AsciiStrnCatS (
+            mFastbootCommonMsgInfo[i].Msg, sizeof (mFastbootCommonMsgInfo[i].Msg),
+            IsSecureBootEnabled () ? "yes" : "no",
+            IsSecureBootEnabled () ? AsciiStrLen ("yes") : AsciiStrLen ("no"));
+        break;
+      case 7:
+        /* Get device status */
+        AsciiStrnCatS (
+            mFastbootCommonMsgInfo[i].Msg, sizeof (mFastbootCommonMsgInfo[i].Msg),
+            IsUnlocked () ? "unlocked" : "locked",
+            IsUnlocked () ? AsciiStrLen ("unlocked") : AsciiStrLen ("locked"));
+        break;
+      }
     }
-
     mFastbootCommonMsgInfo[i].Location = Location;
     Status = DrawMenu (&mFastbootCommonMsgInfo[i], &Height);
     if (Status != EFI_SUCCESS)
       return Status;
     Location += Height;
   }
-
+  IsFastbootCommonMsgInit = TRUE;
   OptionMenuInfo->Info.MenuType = DISPLAY_MENU_FASTBOOT;
   OptionMenuInfo->Info.OptionNum = OptionTotal;
 
diff --git a/QcomModulePkg/Library/BootLib/MenuKeysDetection.c b/QcomModulePkg/Library/BootLib/MenuKeysDetection.c
index 4684c88d90..fb4d325431 100644
--- a/QcomModulePkg/Library/BootLib/MenuKeysDetection.c
+++ b/QcomModulePkg/Library/BootLib/MenuKeysDetection.c
@@ -79,6 +79,7 @@
 #include <Library/BootLinux.h>
 #include <Library/VerifiedBootMenu.h>
 #include <Library/Board.h>
+#include <Library/BootESP.h>
 #include <Uefi.h>
 
 #include <Protocol/EFIVerifiedBoot.h>
@@ -202,6 +203,11 @@ UpdateDeviceStatus (OPTION_MENU_INFO *MsgInfo, INTN Reason)
     DEBUG ((EFI_D_WARN,
           "Reset unbootable slots failed enter fastboot mode\n"));
     break;
+  case ESP:
+    Status = BootESP();
+    DEBUG ((EFI_D_WARN,
+          "Boot to ESP failed, please check the ESP partition existence\n"));
+    break;
   }
 }
 
-- 
2.43.0

